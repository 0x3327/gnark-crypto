// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package polynomial

import (
	"github.com/consensys/gnark-crypto/internal/generator/gkr/small_rational"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"github.com/stretchr/testify/assert"
	"testing"
)

// TODO: Property based tests?
func TestFoldBilinear(t *testing.T) {

	//TODO: Find out why it stalls
	for i := 0; i < 100; i++ {

		// f = c₀ + c₁ X₁ + c₂ X₂ + c₃ X₁ X₂
		var coefficients [4]small_rational.SmallRational
		for i := 0; i < 4; i++ {
			if _, err := coefficients[i].SetRandom(); err != nil {
				t.Error(err)
			}
		}

		var r small_rational.SmallRational
		if _, err := r.SetRandom(); err != nil {
			t.Error(err)
		}

		// interpolate at {0,1}²:
		m := make(MultiLin, 4)
		m[0] = coefficients[0]
		m[1].Add(&coefficients[0], &coefficients[2])
		m[2].Add(&coefficients[0], &coefficients[1])
		m[3].
			Add(&m[1], &coefficients[1]).
			Add(&m[3], &coefficients[3])

		m.Fold(r)

		// interpolate at {r}×{0,1}:
		var expected0, expected1 small_rational.SmallRational
		expected0.
			Mul(&r, &coefficients[1]).
			Add(&expected0, &coefficients[0])

		expected1.
			Mul(&r, &coefficients[3]).
			Add(&expected1, &coefficients[2]).
			Add(&expected0, &expected1)

		//assert.True(t, expected0.Equal(&m[0]))
		assert.Equal(t, expected0.Text(10), m[0].Text(10))
		if !m[0].Equal(&expected0) || !m[1].Equal(&expected1) {
			t.Fail()
		}
	}
}

func TestPrecomputeLagrangeAt3(t *testing.T) {
	polys := computeLagrangeBasis(3)

	expectedPoly := make(Polynomial, 3)

	// \delta_0 = X^2/2 - 3/2X + 1
	expectedPoly[0].SetInterface(1)
	expectedPoly[1].SetInterface("-3/2")
	expectedPoly[2].SetInterface("1/2")

	assert.True(t, polys[0].Equal(expectedPoly), "expected X²/2 - 3/2X + 1, saw %s", polys[0].Text(10))
}

func TestPrecomputeLagrange(t *testing.T) {

	testForDomainSize := func(domainSize uint8) bool {
		polys := computeLagrangeBasis(domainSize)

		for l := uint8(0); l < domainSize; l++ {
			for i := uint8(0); i < domainSize; i++ {
				var I small_rational.SmallRational
				I.SetUint64(uint64(i))
				y := polys[l].Eval(&I)

				if i == l && !y.IsOne() || i != l && !y.IsZero() {
					t.Errorf("domainSize = %d: p_%d(%d) = %s", domainSize, l, i, y.Text(10))
					return false
				}
			}
		}
		return true
	}

	t.Parallel()
	parameters := gopter.DefaultTestParameters()

	const numTests = 3 //int(maxLagrangeDomainSize)

	parameters.MinSuccessfulTests = numTests

	properties := gopter.NewProperties(parameters)

	properties.Property("l'th lagrange polynomials must evaluate to 1 on l and 0 on other values in the domain", prop.ForAll(
		testForDomainSize,
		gen.UInt8Range(2, numTests),
	))

	properties.TestingRun(t, gopter.ConsoleReporter(false))
}

// TODO: Benchmark folding? Algorithms is pretty straightforward; unless we want to measure how well memory management is working

func TestEq4(t *testing.T) {
	x := make([]small_rational.SmallRational, 2)
	x[0].SetInt64(2)
	x[1].SetInt64(3)

	eqX := make(MultiLin, 4)
	eqX[0].SetOne()
	eqX.Eq(x)

	var expected small_rational.SmallRational

	expected.SetInt64(2)
	assert.Equal(t, expected.Text(10), eqX[0].Text(10))

	expected.SetInt64(-3)
	assert.Equal(t, expected.Text(10), eqX[1].Text(10))

	expected.SetInt64(-4)
	assert.Equal(t, expected.Text(10), eqX[2].Text(10))

	expected.SetInt64(6)
	assert.Equal(t, expected.Text(10), eqX[3].Text(10))
}

func TestEvalEq(t *testing.T) {
	x := make([]small_rational.SmallRational, 2)
	x[0].SetInt64(2)
	x[1].SetInt64(3)

	y := make([]small_rational.SmallRational, 2)
	y[0].SetOne()
	y[1].SetZero()

	eq := EvalEq(x, y)

	assert.Equal(t, "-4", eq.Text(10))
}

// TODO: Delete this or TestFoldedEqTable
func TestEvalEqs(t *testing.T) {
	x := make([]small_rational.SmallRational, 2)
	x[0].SetInt64(2)
	x[1].SetInt64(3)

	var one, zero small_rational.SmallRational
	one.SetOne()

	var expected small_rational.SmallRational

	expected.SetInt64(2)
	seen := EvalEq(x, []small_rational.SmallRational{zero, zero})
	assert.True(t, seen.Equal(&expected), "Expected Eq({2,3}, {0,0}) = 2, saw %s", seen.Text(10))

	expected.SetInt64(-3)
	seen = EvalEq(x, []small_rational.SmallRational{zero, one})
	assert.True(t, seen.Equal(&expected), "Expected Eq({2,3}, {0,1}) = -3, saw %s", seen.Text(10))

	expected.SetInt64(-4)
	seen = EvalEq(x, []small_rational.SmallRational{one, zero})
	assert.True(t, seen.Equal(&expected), "Expected Eq({2,3}, {1,0}) = -4, saw %s", seen.Text(10))

	expected.SetInt64(6)
	seen = EvalEq(x, []small_rational.SmallRational{one, one})
	assert.True(t, seen.Equal(&expected), "Expected Eq({2,3}, {1,1}) = 6, saw %s", seen.Text(10))
}

func TestFoldedEqTable(t *testing.T) {
	x := make([]small_rational.SmallRational, 2)
	x[0].SetInt64(2)
	x[1].SetInt64(3)

	eqX := make(MultiLin, 4)
	eqX[0].SetOne()
	eqX.Eq(x)

	eqXpected := make([]small_rational.SmallRational, 4)
	p := make([]small_rational.SmallRational, 2)

	var one small_rational.SmallRational
	one.SetOne()

	for p0 := 0; p0 < 2; p0++ {
		p[1].SetZero()
		for p1 := 0; p1 < 2; p1++ {
			eqXpected[p0*2+p1] = EvalEq(x, p)
			p[1].Add(&p[1], &one)
		}
		p[0].Add(&p[0], &one)
	}

	for i := 0; i < 4; i++ {
		assert.Equal(t, eqXpected[i].Text(10), eqX[i].Text(10), "folded table disagrees with EqEval %d", i)
	}

}

func TestEq2(t *testing.T) {
	eqX := make(MultiLin, 2)
	eqX[0].SetOne()

	var x small_rational.SmallRational
	x.SetInt64(3)

	eqX.Eq([]small_rational.SmallRational{x})

	expectedEqX := make(MultiLin, 2)
	expectedEqX[0].SetInt64(-2)
	expectedEqX[1].SetInt64(3)

	assert.Equal(t, expectedEqX, eqX)
}
