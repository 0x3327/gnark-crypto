import (
    "encoding/json"
    "fmt"
    "github.com/consensys/gnark-crypto/internal/generator/test_vector_utils/small_rational"
    "github.com/consensys/gnark-crypto/internal/generator/test_vector_utils/small_rational/gkr"
    "github.com/consensys/gnark-crypto/internal/generator/test_vector_utils/small_rational/polynomial"
    "github.com/consensys/gnark-crypto/internal/generator/test_vector_utils/small_rational/sumcheck"
    "github.com/consensys/gnark-crypto/internal/generator/test_vector_utils/small_rational/test_vector_utils"
    "os"
    "path/filepath"
	"reflect"
)

func main() {
    if err := GenerateVectors(); err != nil {
        fmt.Println(err.Error())
        os.Exit(-1)
    }
}

func GenerateVectors() error {
    testDirPath, err := filepath.Abs("gkr/test_vectors")
    if err != nil {
        return err
    }

    fmt.Printf("generating GKR test cases: scanning directory %s for test specs\n", testDirPath)

    dirEntries, err := os.ReadDir(testDirPath)
    if err != nil {
        return err
    }
    for _, dirEntry := range dirEntries {
        if !dirEntry.IsDir() {

            if filepath.Ext(dirEntry.Name()) == ".json" {

                fmt.Println("\tprocessing", dirEntry.Name())

                path := filepath.Join(testDirPath, dirEntry.Name())

                var testCase *TestCase
                testCase, err = newTestCase(path)
                if err != nil {
                    return err
                }

                testCase.Transcript.Update(0)
                proof := gkr.Prove(testCase.Circuit, testCase.FullAssignment, testCase.Transcript)

                if testCase.Info.Proof, err = toPrintableProof(proof); err != nil {
                    return err
                }
                var outBytes []byte
                if outBytes, err = json.MarshalIndent(testCase.Info, "", "\t"); err == nil {
                    if err = os.WriteFile(path, outBytes, 0); err != nil {
                        return err
                    }
                } else {
                    return err
                }

				testCase, err = newTestCase(path)
				if err != nil {
					return err
                }
				testCase.Transcript.Update(0)

				if !gkr.Verify(testCase.Circuit, testCase.InOutAssignment, proof, testCase.Transcript) {
					return fmt.Errorf("verification failed")
                }
            }
        }
    }

    return nil
}

func toPrintableProof(proof gkr.Proof) (PrintableProof, error) {
	res := make(PrintableProof, len(proof))

	for i, proofI := range proof {
		if proofI == nil {
			res[i] = nil
		} else {
			res[i] = make([]PrintableSumcheckProof, len(proofI))
			for j, proofIJ := range proofI {

				partialSumPolys := make([][]interface{}, len(proofIJ.PartialSumPolys))
				for k, partialK := range proofIJ.PartialSumPolys {
					partialSumPolys[k] = test_vector_utils.ElementSliceToInterfaceSlice(partialK)
				}

				res[i][j] = PrintableSumcheckProof{
					FinalEvalProof:  test_vector_utils.ElementSliceToInterfaceSlice(proofIJ.FinalEvalProof),
					PartialSumPolys: partialSumPolys,
				}
			}
		}
	}
	return res, nil
}

{{template "gkrTestVectors" .}}