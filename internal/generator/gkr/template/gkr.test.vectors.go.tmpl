{{define "gkrTestVectors"}}

{{$GkrPackagePrefix := select .OutsideGkrPackage "" "gkr."}}

{{$Circuit          := print $GkrPackagePrefix "Circuit"}}
{{$Gate             := print $GkrPackagePrefix "Gate"}}
{{$Proof            := print $GkrPackagePrefix "Proof"}}
{{$WireAssignment   := print $GkrPackagePrefix "WireAssignment"}}
{{$Wire             := print $GkrPackagePrefix "Wire"}}
{{$CircuitLayer     := print $GkrPackagePrefix "CircuitLayer"}}

type WireInfo struct {
	Gate   string  `json:"gate"`
	Inputs [][]int `json:"inputs"`
}

type CircuitInfo [][]WireInfo

var circuitCache = make(map[string]{{$Circuit}})

func getCircuit(path string) ({{$Circuit}}, error) {
	path, err := filepath.Abs(path)
	if err != nil {
		return nil, err
	}
	if circuit, ok := circuitCache[path]; ok {
		return circuit, nil
	}
	var bytes []byte
	if bytes, err = os.ReadFile(path); err == nil {
		var circuitInfo CircuitInfo
		if err = json.Unmarshal(bytes, &circuitInfo); err == nil {
			circuit := circuitInfo.toCircuit()
			circuitCache[path] = circuit
			return circuit, nil
		} else {
			return nil, err
		}
	} else {
		return nil, err
	}
}

func (c CircuitInfo) toCircuit() (circuit {{$Circuit}}) {
	isOutput := make(map[*{{$Wire}}]interface{})
	circuit = make({{$Circuit}}, len(c))
	for i := len(c) - 1; i >= 0; i-- {
		circuit[i] = make({{$CircuitLayer}}, len(c[i]))
		for j, wireInfo := range c[i] {
			circuit[i][j].Gate = gates[wireInfo.Gate]
			circuit[i][j].Inputs = make([]*{{$Wire}}, len(wireInfo.Inputs))
			isOutput[&circuit[i][j]] = nil
			for k, inputCoord := range wireInfo.Inputs {
				if len(inputCoord) != 2 {
					panic("circuit wire has two coordinates")
				}
				input := &circuit[inputCoord[0]][inputCoord[1]]
				input.NumOutputs++
				circuit[i][j].Inputs[k] = input
				delete(isOutput, input)
			}
			if (i == len(c)-1) != (len(circuit[i][j].Inputs) == 0) {
				panic("wire is input if and only if in last layer")
			}
		}
	}

	for k := range isOutput {
		k.NumOutputs = 1
	}

	return
}

var gates map[string]{{$Gate}}

func init() {
	gates = make(map[string]{{$Gate}})
	gates["identity"] = {{$GkrPackagePrefix}}IdentityGate{}
	gates["mul"] = mulGate{}
	gates["mimc"] = mimcCipherGate{} //TODO: Add ark
}

type mimcCipherGate struct {
	ark {{.ElementType}}
}

func (m mimcCipherGate) Evaluate(input ...{{.ElementType}}) (res {{.ElementType}}) {
	var sum {{.ElementType}}

	sum.
		Add(&input[0], &input[1]).
		Add(&sum, &m.ark)

	res.Square(&sum)    // sum^2
	res.Mul(&res, &sum) // sum^3
	res.Square(&res)    //sum^6
	res.Mul(&res, &sum) //sum^7

	return
}

func (m mimcCipherGate) Degree() int {
	return 7
}

func proofEquals(expected {{$Proof}}, seen {{$Proof}}) error {
	if len(expected) != len(seen) {
		return fmt.Errorf("length mismatch %d ≠ %d", len(expected), len(seen))
	}
	for i, x := range expected {
		xSeen := seen[i]
		if len(expected) != len(seen) {
			return fmt.Errorf("length mismatch %d ≠ %d", len(x), len(xSeen))
		}
		for j, y := range x {
			ySeen := xSeen[j]

			if ySeen.FinalEvalProof == nil {
				if seenFinalEval := y.FinalEvalProof.([]{{.ElementType}}); 0 != len(seenFinalEval) {
					return fmt.Errorf("length mismatch %d ≠ %d", 0, len(seenFinalEval))
				}
			} else {
				if err := test_vector_utils.SliceEquals(y.FinalEvalProof.([]{{.ElementType}}), ySeen.FinalEvalProof.([]{{.ElementType}})); err != nil {
					return fmt.Errorf("final evaluation proof mismatch")
				}
			}
			if err := test_vector_utils.PolynomialSliceEquals(y.PartialSumPolys, ySeen.PartialSumPolys); err != nil {
				return err
			}
		}
	}
	return nil
}

type PrintableProof [][]PrintableSumcheckProof

type PrintableSumcheckProof struct {
	FinalEvalProof  interface{}     `json:"finalEvalProof"`
	PartialSumPolys [][]interface{} `json:"partialSumPolys"`
}

func unmarshalProof(printable PrintableProof) ({{$Proof}}, error) {
	proof := make({{$Proof}}, len(printable))
	for i := range printable {
		proof[i] = make([]sumcheck.Proof, len(printable[i]))
		for j, printableSumcheck := range printable[i] {
			finalEvalProof := []{{.ElementType}}(nil)

			if printableSumcheck.FinalEvalProof != nil {
				finalEvalSlice := reflect.ValueOf(printableSumcheck.FinalEvalProof)
				finalEvalProof = make([]{{.ElementType}}, finalEvalSlice.Len())
				for k := range finalEvalProof {
					if _, err := {{setElement "finalEvalProof[k]" "finalEvalSlice.Index(k).Interface()" .ElementType}}; err != nil {
						return nil, err
					}
				}
			}

			proof[i][j] = sumcheck.Proof{
				PartialSumPolys: make([]polynomial.Polynomial, len(printableSumcheck.PartialSumPolys)),
				FinalEvalProof:  finalEvalProof,
			}
			for k := range printableSumcheck.PartialSumPolys {
				var err error
				if proof[i][j].PartialSumPolys[k], err = test_vector_utils.SliceToElementSlice(printableSumcheck.PartialSumPolys[k]); err != nil {
					return nil, err
				}
			}
		}
	}
	return proof, nil
}

type TestCase struct {
	Circuit         {{$Circuit}}
	Transcript      sumcheck.ArithmeticTranscript
	Proof           {{$Proof}}
	FullAssignment  {{$WireAssignment}}
	InOutAssignment {{$WireAssignment}}
	{{if .RetainTestCaseRawInfo}}Info TestCaseInfo{{end}}
}

type TestCaseInfo struct {
	Hash    string          `json:"hash"`
	Circuit string          `json:"circuit"`
	Input   [][]interface{} `json:"input"`
	Output  [][]interface{} `json:"output"`
	Proof   PrintableProof  `json:"proof"`
}

type ParsedTestCase struct {
	FullAssignment  {{$WireAssignment}}
	InOutAssignment {{$WireAssignment}}
	Proof           {{$Proof}}
	Hash            test_vector_utils.HashMap
	Circuit         {{$Circuit}}
}

var parsedTestCases = make(map[string]*ParsedTestCase)

func newTestCase(path string) (*TestCase, error) {
	path, err := filepath.Abs(path)
	if err != nil {
		return nil, err
	}
	dir := filepath.Dir(path)

	parsedCase, ok := parsedTestCases[path]
	if !ok {
		var bytes []byte
		if bytes, err = os.ReadFile(path); err == nil {
			var info TestCaseInfo
			err = json.Unmarshal(bytes, &info)
			if err != nil {
				return nil, err
			}

			var circuit {{$Circuit}}
			if circuit, err = getCircuit(filepath.Join(dir, info.Circuit)); err != nil {
				return nil, err
			}
			var hash test_vector_utils.HashMap
			if hash, err = test_vector_utils.GetHash(filepath.Join(dir, info.Hash)); err != nil {
				return nil, err
			}
			var proof {{$Proof}}
			if proof, err = unmarshalProof(info.Proof); err != nil {
				return nil, err
			}

			fullAssignment := make({{$WireAssignment}})
			inOutAssignment := make({{$WireAssignment}})
			assignmentSize := len(info.Input[0])

			{
				i := len(circuit) - 1

				if expected, seen := len(circuit[i]), len(info.Input); expected != seen {
					return nil, fmt.Errorf("input layer length %d must match that of input vector %d", expected, seen)
				}

				for j := range circuit[i] {
					wire := &circuit[i][j]
					var wireAssignment []{{.ElementType}}
					if wireAssignment, err = test_vector_utils.SliceToElementSlice(info.Input[j]); err != nil {
						return nil, err
					}
					fullAssignment[wire] = wireAssignment
					inOutAssignment[wire] = wireAssignment
				}
			}

			for i := len(circuit) - 2; i >= 0; i-- {
				for j := range circuit[i] {
					wire := &circuit[i][j]
					assignment := make(polynomial.MultiLin, assignmentSize)
					in := make([]{{.ElementType}}, len(wire.Inputs))
					for k := range assignment {
						for l, inputWire := range circuit[i][j].Inputs {
							in[l] = fullAssignment[inputWire][k]
						}
						assignment[k] = wire.Gate.Evaluate(in...)
					}

					fullAssignment[wire] = assignment
				}
			}

			if expected, seen := len(circuit[0]), len(info.Output); expected != seen {
				return nil, fmt.Errorf("output layer length %d must match that of input vector %d", expected, seen)
			}
			for j := range circuit[0] {
				wire := &circuit[0][j]
				if inOutAssignment[wire], err = test_vector_utils.SliceToElementSlice(info.Output[j]); err != nil {
					return nil, err
				}
				if err = test_vector_utils.SliceEquals(inOutAssignment[wire], fullAssignment[wire]); err != nil {
					return nil, err
				}
			}

			parsedCase = &ParsedTestCase{
				FullAssignment:  fullAssignment,
				InOutAssignment: inOutAssignment,
				Proof:           proof,
				Hash:            hash,
				Circuit:         circuit,
			}

			parsedTestCases[path] = parsedCase
		} else {
			return nil, err
		}
	}

	return &TestCase{
		Circuit:         parsedCase.Circuit,
		Transcript:      &test_vector_utils.MapHashTranscript{HashMap: parsedCase.Hash},
		FullAssignment:  parsedCase.FullAssignment,
		InOutAssignment: parsedCase.InOutAssignment,
		Proof:           parsedCase.Proof,
	}, nil
}

type mulGate struct{}

func (m mulGate) Evaluate(element ...{{.ElementType}}) (result {{.ElementType}}) {
	result.Mul(&element[0], &element[1])
	return
}

func (m mulGate) Degree() int {
	return 2
}

{{end}}

{{- define "setElement element value elementType"}}
{{- if eq .elementType "fr.Element"}} test_vector_utils.SetElement(&{{.element}}, {{.value}})
{{- else if eq .elementType "small_rational.SmallRational"}} {{.element}}.SetInterface({{.value}})
{{- else}}
{{print "\"UNEXPECTED TYPE" .elementType "\""}}
{{- end}}
{{- end}}