
import (
	"{{.FieldPackagePath}}"
	"{{.FieldPackagePath}}/mimc"
	"{{.FieldPackagePath}}/polynomial"
	"{{.FieldPackagePath}}/sumcheck"
	"{{.FieldPackagePath}}/test_vector_utils"
	"github.com/stretchr/testify/assert"
	"fmt"
	"hash"
	"os"
	"strconv"
	"testing"
	"path/filepath"
	"encoding/json"
	"reflect"
)

{{$GenerateLargeTests := .GenerateTests}} {{/* this is redundant. soon to be removed if a use case for it doesn't come back */}}

func TestNoGateTwoInstances(t *testing.T) {
	// Testing a single instance is not possible because the sumcheck implementation doesn't cover the trivial 0-variate case
	testNoGate(t, []{{.ElementType}}{four, three})
}

func TestNoGate(t *testing.T) {
	testManyInstances(t, 1, testNoGate)
}

func TestSingleMulGateTwoInstances(t *testing.T) {
	testSingleMulGate(t, []{{.ElementType}}{four, three}, []{{.ElementType}}{two, three})
}

func TestSingleMulGate(t *testing.T) {
	testManyInstances(t, 2, testSingleMulGate)
}

func TestSingleInputTwoIdentityGatesTwoInstances(t *testing.T) {

	testSingleInputTwoIdentityGates(t, []{{.ElementType}}{two, three})
}

func TestSingleInputTwoIdentityGates(t *testing.T) {

	testManyInstances(t, 2, testSingleInputTwoIdentityGates)
}

func TestSingleInputTwoIdentityGatesComposedTwoInstances(t *testing.T) {
	testSingleInputTwoIdentityGatesComposed(t, []{{.ElementType}}{two, one})
}

func TestSingleInputTwoIdentityGatesComposed(t *testing.T) {
	testManyInstances(t, 1, testSingleInputTwoIdentityGatesComposed)
}

func TestSingleMimcCipherGateTwoInstances(t *testing.T) {
	testSingleMimcCipherGate(t, []{{.ElementType}}{one, one}, []{{.ElementType}}{one, two})
}

func TestSingleMimcCipherGate(t *testing.T) {
	testManyInstances(t, 2, testSingleMimcCipherGate)
}

func TestATimesBSquaredTwoInstances(t *testing.T) {
	testATimesBSquared(t, 2, []{{.ElementType}}{one, one}, []{{.ElementType}}{one, two})
}

func TestShallowMimcTwoInstances(t *testing.T) {
	testMimc(t, 2, []{{.ElementType}}{one, one}, []{{.ElementType}}{one, two})
}

{{- if $GenerateLargeTests}}
func TestMimcTwoInstances(t *testing.T) {
	testMimc(t, 93, []{{.ElementType}}{one, one}, []{{.ElementType}}{one, two})
}

func TestMimc(t *testing.T) {
	testManyInstances(t, 2, generateTestMimc(93))
}

func generateTestMimc(numRounds int) func(*testing.T, ...[]{{.ElementType}}) {
	return func(t *testing.T, inputAssignments ...[]{{.ElementType}}) {
		testMimc(t, numRounds, inputAssignments...)
	}
}

{{- end}}

func TestSumcheckFromSingleInputTwoIdentityGatesGateTwoInstances(t *testing.T) {
	circuit := Circuit{ { Wire{
		Gate:       nil,
		Inputs:     []*Wire{},
		NumOutputs: 2,
	} } }

	wire := &circuit[0][0]

	assignment := WireAssignment{&circuit[0][0]: []{{.ElementType}}{two, three}}

	claimsManagerGen := func() *claimsManager {
		manager := newClaimsManager(circuit, assignment, nil)
		manager.add(wire, []{{.ElementType}}{three}, five)
		manager.add(wire, []{{.ElementType}}{four}, six)
		return &manager
	}

	transcriptGen := sumcheck.NewMessageCounterGenerator(4, 1)

	proof := sumcheck.Prove(claimsManagerGen().getClaim(wire), transcriptGen())
	sumcheck.Verify(claimsManagerGen().getLazyClaim(wire), proof, transcriptGen())
}

func setHas[T comparable](set *map[T]struct{}, elt T) bool {
	_, ok := (*set)[elt]
	return ok
}

func setAdd[T comparable](set *map[T]struct{}, elt T) {
	(*set)[elt] = struct{}{}
}

type stack struct {
	size  int
	slice []*Wire
}

func (s *stack) pop() *Wire {
	s.size--
	return s.slice[s.size]
}

func (s *stack) push(v *Wire) {
	if s.size < len(s.slice) {
		s.slice[s.size] = v
	} else {
		s.slice = append(s.slice, v)
	}
	s.size++
}

func topologicalSort(c Circuit) (sortedWires []*Wire) {
	circuitSizeEstimate := len(c)
	sortedWires = make([]*Wire, 0, circuitSizeEstimate)
	visited := make(map[*Wire]struct{}, circuitSizeEstimate)

	stack := stack{slice: make([]*Wire, circuitSizeEstimate)}

	for i := range c {
		for j := range c[i] {
			w := &c[i][j]
			stackTraceSet := make(map[*Wire]struct{}, circuitSizeEstimate)

			if !w.IsInput() && !setHas(&visited, w) {
				stack.push(w)

				for stack.size != 0 {
					w := stack.pop()

					if setHas(&stackTraceSet, w) { //fully explored
						sortedWires = append(sortedWires, w)
						delete(stackTraceSet, w)
					} else {
						setAdd(&stackTraceSet, w)
						stack.push(w)

						for _, v := range w.Inputs {
							if setHas(&stackTraceSet, v) {
								panic("cycle detected")
							} else if !setHas(&visited, v) {
								setAdd(&visited, v)
								stack.push(v)
							}
						}
					}
				}
			}
		}
	}
	return
}

// complete the circuit evaluation from input values
func (a WireAssignment) complete(c Circuit) WireAssignment {

	sortedWires := topologicalSort(c)
	numEvaluations := 0

	for _, w := range sortedWires {
		if !w.IsInput() {
			if numEvaluations == 0 {
				numEvaluations = len(a[w.Inputs[0]])
			}
			evals := make([]fr.Element, numEvaluations)
			ins := make([]fr.Element, len(w.Inputs))
			for k := 0; k < numEvaluations; k++ {
				for inI, in := range w.Inputs {
					ins[inI] = a[in][k]
				}
				evals[k] = w.Gate.Evaluate(ins...)
			}
			a[w] = evals
		}
	}
	return a
}

var one, two, three, four, five, six {{.ElementType}}

func init() {
	one.SetOne()
	two.Double(&one)
	three.Add(&two, &one)
	four.Double(&two)
	five.Add(&three, &two)
	six.Double(&three)
}

var testManyInstancesLogMaxInstances = -1

func getLogMaxInstances(t *testing.T) int {
	if testManyInstancesLogMaxInstances == -1 {

		s := os.Getenv("GKR_LOG_INSTANCES")
		if s == "" {
			testManyInstancesLogMaxInstances = 5
		} else {
			var err error
			testManyInstancesLogMaxInstances, err = strconv.Atoi(s)
			if err != nil {
				t.Error(err)
			}
		}

	}
	return testManyInstancesLogMaxInstances
}

func testManyInstances(t *testing.T, numInput int, test func(*testing.T, ...[]{{.ElementType}})) {
	fullAssignments := make([][]{{.ElementType}}, numInput)
	maxSize := 1 << getLogMaxInstances(t)

	t.Log("Entered test orchestrator, assigning and randomizing inputs")

	for i := range fullAssignments {
		fullAssignments[i] = make([]fr.Element, maxSize)
		setRandom(fullAssignments[i])
	}

	inputAssignments := make([][]{{.ElementType}}, numInput)
	for numEvals := maxSize; numEvals <= maxSize; numEvals *= 2 {
		for i, fullAssignment := range fullAssignments {
			inputAssignments[i] = fullAssignment[:numEvals]
		}

		t.Log("Selected inputs for test")
		test(t, inputAssignments...)
	}
}

func testNoGate(t *testing.T, inputAssignments ...[]{{.ElementType}}) {
	c := Circuit{
		{
			{
				Inputs:     []*Wire{},
				NumOutputs: 1,
				Gate:       nil,
			},
		},
	}

	assignment := WireAssignment{&c[0][0]: inputAssignments[0]}

	proof := Prove(c, assignment, sumcheck.NewMessageCounter(1, 1))

	// Even though a hash is called here, the proof is empty

	if !Verify(c, assignment, proof, sumcheck.NewMessageCounter(1, 1)) {
		t.Error("Proof rejected")
	}
}

func testSingleMulGate(t *testing.T, inputAssignments ...[]{{.ElementType}}) {
	c := make(Circuit, 2)

	c[1] = CircuitLayer{
		{
			Inputs:     []*Wire{},
			NumOutputs: 1,
			Gate:       nil,
		},
		{
			Inputs:     []*Wire{},
			NumOutputs: 1,
			Gate:       nil,
		},
	}

	c[0] = CircuitLayer{ {
		Inputs:     []*Wire{&c[1][0], &c[1][1]},
		NumOutputs: 1,
		Gate:       mulGate{},
	} }

	assignment := WireAssignment{&c[1][0]: inputAssignments[0], &c[1][1]: inputAssignments[1]}.complete(c)

	proof := Prove(c, assignment, sumcheck.NewMessageCounter(1, 1))

	if !Verify(c, assignment, proof, sumcheck.NewMessageCounter(1, 1)) {
		t.Error("Proof rejected")
	}

	if Verify(c, assignment, proof, sumcheck.NewMessageCounter(0, 1)) {
		t.Error("Bad proof accepted")
	}
}

func testSingleInputTwoIdentityGates(t *testing.T, inputAssignments ...[]{{.ElementType}}) {
	c := make(Circuit, 2)

	c[1] = CircuitLayer{
		{
			Inputs:     []*Wire{},
			NumOutputs: 2,
			Gate:       nil,
		},
	}

	c[0] = CircuitLayer{
		{
			Inputs:     []*Wire{&c[1][0]},
			NumOutputs: 1,
			Gate:       IdentityGate{},
		},
		{
			Inputs:     []*Wire{&c[1][0]},
			NumOutputs: 1,
			Gate:       IdentityGate{},
		},
	}

	assignment := WireAssignment{&c[1][0]: inputAssignments[0]}.complete(c)

	proof := Prove(c, assignment, sumcheck.NewMessageCounter(0, 1))

	if !Verify(c, assignment, proof, sumcheck.NewMessageCounter(0, 1)) {
		t.Error("Proof rejected")
	}

	if Verify(c, assignment, proof, sumcheck.NewMessageCounter(1, 1)) {
		t.Error("Bad proof accepted")
	}
}

func testSingleMimcCipherGate(t *testing.T, inputAssignments ...[]{{.ElementType}}) {
	c := make(Circuit, 2)

	c[1] = CircuitLayer{
		{
			Inputs:     []*Wire{},
			NumOutputs: 1,
			Gate:       nil,
		},
		{
			Inputs:     []*Wire{},
			NumOutputs: 1,
			Gate:       nil,
		},
	}

	c[0] = CircuitLayer{
		{
			Inputs:     []*Wire{&c[1][0], &c[1][1]},
			NumOutputs: 1,
			Gate:       mimcCipherGate{},
		},
	}
	t.Log("Evaluating all circuit wires")
	assignment := WireAssignment{&c[1][0]: inputAssignments[0], &c[1][1]: inputAssignments[1]}.complete(c)
	t.Log("Circuit evaluation complete")
	proof := Prove(c, assignment, sumcheck.NewMessageCounter(0, 1))
	t.Log("Proof complete")
	if !Verify(c, assignment, proof, sumcheck.NewMessageCounter(0, 1)) {
		t.Error("Proof rejected")
	}
	t.Log("Successful verification complete")
	if Verify(c, assignment, proof, sumcheck.NewMessageCounter(1, 1)) {
		t.Error("Bad proof accepted")
	}
	t.Log("Unsuccessful verification complete")
}

func testSingleInputTwoIdentityGatesComposed(t *testing.T, inputAssignments ...[]{{.ElementType}}) {
	c := make(Circuit, 3)

	c[2] = CircuitLayer{ {
		Gate:       nil,
		Inputs:     []*Wire{},
		NumOutputs: 1,
	}}
	c[1] = CircuitLayer{ {
		Gate:       IdentityGate{},
		Inputs:     []*Wire{&c[2][0]},
		NumOutputs: 1,
	}}
	c[0] = CircuitLayer{ {
		Gate:       IdentityGate{},
		Inputs:     []*Wire{&c[1][0]},
		NumOutputs: 1,
	}}

	assignment := WireAssignment{&c[2][0]: inputAssignments[0]}.complete(c)

	proof := Prove(c, assignment, sumcheck.NewMessageCounter(0, 1))

	if !Verify(c, assignment, proof, sumcheck.NewMessageCounter(0, 1)) {
		t.Error("Proof rejected")
	}

	if Verify(c, assignment, proof, sumcheck.NewMessageCounter(1, 1)) {
		t.Error("Bad proof accepted")
	}
}

func mimcCircuit(numRounds int) Circuit {
	c := make(Circuit, numRounds+1)

	c[numRounds] = CircuitLayer{
		{
			Inputs:     []*Wire{},
			NumOutputs: 1,
			Gate:       nil,
		},
		{
			Inputs:     []*Wire{},
			NumOutputs: numRounds,
			Gate:       nil,
		},
	}

	for i := numRounds; i > 0; i-- {
		c[i-1] = CircuitLayer{
			{
				Inputs:     []*Wire{&c[i][0], &c[numRounds][1]},
				NumOutputs: 1,
				Gate:       mimcCipherGate{}, //TODO: Put arks in there
			},
		}
	}
	return c
}

func testMimc(t *testing.T, numRounds int, inputAssignments ...[]{{.ElementType}}) {
	//TODO: Implement mimc correctly. Currently, the computation is mimc(a,b) = cipher( cipher( ... cipher(a, b), b) ..., b)
	// @AlexandreBelling: Please explain the extra layers in https://github.com/ConsenSys/gkr-mimc/blob/81eada039ab4ed403b7726b535adb63026e8011f/examples/mimc.go#L10

	c := mimcCircuit(numRounds)

	t.Log("Evaluating all circuit wires")
	assignment := WireAssignment{&c[numRounds][0]: inputAssignments[0], &c[numRounds][1]: inputAssignments[1]}.complete(c)
	t.Log("Circuit evaluation complete")

	proof := Prove(c, assignment, sumcheck.NewMessageCounter(0, 1))

	t.Log("Proof finished")
	if !Verify(c, assignment, proof, sumcheck.NewMessageCounter(0, 1)) {
		t.Error("Proof rejected")
	}

	t.Log("Successful verification finished")
	if Verify(c, assignment, proof, sumcheck.NewMessageCounter(1, 1)) {
		t.Error("Bad proof accepted")
	}
	t.Log("Unsuccessful verification finished")
}

func testATimesBSquared(t *testing.T, numRounds int, inputAssignments ...[]{{.ElementType}}) {
	// This imitates the MiMC circuit

	c := make(Circuit, numRounds+1)

	c[numRounds] = CircuitLayer{
		{
			Inputs:     []*Wire{},
			NumOutputs: 1,
			Gate:       nil,
		},
		{
			Inputs:     []*Wire{},
			NumOutputs: numRounds,
			Gate:       nil,
		},
	}

	for i := numRounds; i > 0; i-- {
		c[i-1] = CircuitLayer{
			{
				Inputs:     []*Wire{&c[i][0], &c[numRounds][1]},
				NumOutputs: 1,
				Gate:       mulGate{},
			},
		}
	}

	assignment := WireAssignment{&c[numRounds][0]: inputAssignments[0], &c[numRounds][1]: inputAssignments[1]}.complete(c)

	proof := Prove(c, assignment, sumcheck.NewMessageCounter(0, 1))

	if !Verify(c, assignment, proof, sumcheck.NewMessageCounter(0, 1)) {
		t.Error("Proof rejected")
	}

	if Verify(c, assignment, proof, sumcheck.NewMessageCounter(1, 1)) {
		t.Error("Bad proof accepted")
	}
}

func setRandom(slice []{{.ElementType}}) {
	for i := range slice {
		slice[i].SetRandom()
	}
}

func generateTestProver(path string) func(t *testing.T) {
	return func(t *testing.T) {
		testCase, err := newTestCase(path)
		assert.NoError(t, err)
		testCase.Transcript.Update(0)
		proof := Prove(testCase.Circuit, testCase.FullAssignment, testCase.Transcript)
		assert.NoError(t, proofEquals(testCase.Proof, proof))
	}
}

func generateTestVerifier(path string) func(t *testing.T) {
	return func(t *testing.T) {
		testCase, err := newTestCase(path)
		assert.NoError(t, err)
		testCase.Transcript.Update(0)
		success := Verify(testCase.Circuit, testCase.InOutAssignment, testCase.Proof, testCase.Transcript)
		assert.True(t, success)

		testCase, err = newTestCase(path)
		assert.NoError(t, err)
		testCase.Transcript.Update(1)
		success = Verify(testCase.Circuit, testCase.InOutAssignment, testCase.Proof, testCase.Transcript)
		assert.False(t, success)
	}
}

func TestGkrVectors(t *testing.T) {

	testDirPath := "{{.TestVectorsRelativePath}}"
	dirEntries, err := os.ReadDir(testDirPath)
	assert.NoError(t, err)
	for _, dirEntry := range dirEntries {
		if !dirEntry.IsDir() {

			if filepath.Ext(dirEntry.Name()) == ".json" {
				path := filepath.Join(testDirPath, dirEntry.Name())
				noExt := dirEntry.Name()[:len(dirEntry.Name())-len(".json")]

				t.Run(noExt+"_prover", generateTestProver(path))
				t.Run(noExt+"_verifier", generateTestVerifier(path))

			}
		}
	}
}

func proofEquals(expected Proof, seen Proof) error {
	if len(expected) != len(seen) {
		return fmt.Errorf("length mismatch %d ≠ %d", len(expected), len(seen))
	}
	for i, x := range expected {
		xSeen := seen[i]
		if len(expected) != len(seen) {
			return fmt.Errorf("length mismatch %d ≠ %d", len(x), len(xSeen))
		}
		for j, y := range x {
			ySeen := xSeen[j]

			if ySeen.FinalEvalProof == nil {
				if seenFinalEval := y.FinalEvalProof.([]{{.ElementType}}); len(seenFinalEval) != 0 {
					return fmt.Errorf("length mismatch %d ≠ %d", 0, len(seenFinalEval))
				}
			} else {
				if err := test_vector_utils.SliceEquals(y.FinalEvalProof.([]{{.ElementType}}), ySeen.FinalEvalProof.([]{{.ElementType}})); err != nil {
					return fmt.Errorf("final evaluation proof mismatch")
				}
			}
			if err := test_vector_utils.PolynomialSliceEquals(y.PartialSumPolys, ySeen.PartialSumPolys); err != nil {
				return err
			}
		}
	}
	return nil
}

func BenchmarkGkrMimc(b *testing.B) {
	const N = 1 << 19
	fmt.Println("creating circuit structure")
	c := mimcCircuit(91)

	in0 := make([]fr.Element, N)
	in1 := make([]fr.Element, N)
	setRandom(in0)
	setRandom(in1)

	fmt.Println("evaluating circuit")
	assignment := WireAssignment{&c[len(c)-1][0]: in0, &c[len(c)-1][1]: in1}.complete(c)

	//b.ResetTimer()
	fmt.Println("constructing proof")
	Prove(c, assignment, newMimcTranscript())
}

// TODO: Move into main package?
type hashTranscript struct {
	hash          hash.Hash
	nextAvailable bool
}

func newMimcTranscript() sumcheck.ArithmeticTranscript {
	return &hashTranscript{hash: mimc.NewMiMC()}
}

func (t *hashTranscript) hashToField() fr.Element {
	var res fr.Element
	res.SetBytes(t.hash.Sum(nil))
	return res
}

func toBytes(i interface{}) []byte {
	switch v := i.(type) {
	case fr.Element:
		return v.Marshal()
	case *fr.Element:
		return v.Marshal()
	}
	panic(fmt.Errorf("can't serialize type %T", i))
}

func (t *hashTranscript) Update(i ...interface{}) {
	if len(i) == 0 {
		t.hash.Write([]byte{})
	}
	for _, iI := range i {
		t.hash.Write(toBytes(iI))
	}
	t.nextAvailable = true
}

func (t *hashTranscript) Next(i ...interface{}) fr.Element {
	if !t.nextAvailable || len(i) != 0 {
		t.Update(i...)
	}
	t.nextAvailable = false
	return t.hashToField()
}

func (t *hashTranscript) NextN(n int, i ...interface{}) []fr.Element {
	if n <= 0 {
		return []fr.Element{}
	}
	res := make([]fr.Element, n)
	res[0] = t.Next(i...)
	for j := 1; j < n; j++ {
		res[j] = t.Next()
	}
	return res
}

{{template "gkrTestVectors" .}}